# -*- coding: utf-8 -*-
"""Numpy (session 2)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19O2BZBHVNP28GRDnzFi-ygLz2H_77hF_
"""

import numpy as np

list = [ 1 , '2' , 3 , 4 , 5]  # carry diffrent data types
type(list)

array = np.array([[1,'2',3], [ 4,5,6], [7,8,9]]) #just 1 type

type(array)

array.shape

np.empty([3,3]) #create random data

np.zeros(3)

np.zeros([5,5])

np.ones([3,3])

np.eye(3)

"""#VSTACK vs HSTACK"""

arr1 = np.array([1,2,3])
arr2 = np.array([4,5,6])
arr3 = np.vstack([arr1,arr2])
arr3

arr4 = np.hstack([arr1,arr2])
arr4

np.arange(0,10)

np.arange(0,10,2) # 0:10 step=0

np.linspace(0,10,3) # number of parameters = 3

"""50 numbers from 0:10"""

np.empty(50)

np.arange(0 , 10 , 10/50)

np.linspace(0 , 10 , 50)

np.random.rand(2)

np.random.rand(5,5) # uniform distribution (average numbers is so close)

np.random.randn(5,5) # normal distribution

np.random.randint(0 , 100 , 10 )

np.arange(25)

np.linspace(0,50,10)

np.random.uniform(1.5 , 1.4 , 10 ) # generate float number

"""#Reshape"""

arr1 = np.arange(25)
arr2 = np.random.randint(0 , 50 , 10)

arr1

arr2

new_arr = arr1.reshape(5,5)

new_arr

new_arr.shape

# new_arr.max()
np.max(new_arr)

np.min(new_arr)

np.argmax(new_arr)  # index of largest number

np.argmin(new_arr)  # index of minmum number

#convert from 1d to 2d
array = np.array([11,22,33,44,5])
array.shape

array = np.array([[11,22,33,44,5] ,[1,3,55,66,4]])
array.shape

array.shape[0] # nmber of rows

array.shape[1] # nmber of columns

def reshape_arr(arr , flag= 'col'):
  if flag == 'col':
    result = arr.reshape(arr.shape[0],1)
  elif flag =='row':
    result = arr.reshape(1,arr.shape[1] )
  else:
    result = print('error')
  return result

reshape_arr(np.array([1,3,5,7]),flag='col')

"""#indexing"""

arr = np.arange(0,10)
arr

arr[2]

arr[:6] # indexing
arr[0:6] #selection

arr[0:4] = 100
arr

array = np.arange(0,11)
array

new_slice = array[0:6]
new_slice

new_slice[:] = 99  # licing edite the refrence value in memory so it's better to take a copy
array

arr_copy = array.copy()
arr_copy

arr2 =  np.array([[1,2,3],
                  [4,5,6],
                  [7,8,9]])

arr2[1][1]

arr2[1,1]

arr2[0:2,0:2]

"""#selection"""

array = np.arange(0,11)
array

array > 4

array[array > 4]

"""#Broad casting :applying

* arithmitic operations on matrix & vector
"""

y = [1,2,3,4,5]
scaler = 5
result = y + scaler

y = np.array([1,2,3,4,5])
scaler = 5
result = y + scaler
result

"""1D with 2D"""

arr1 = np.array([[1,3,5,7] ,[1,3,5,7]])
arr2 = np.array([1,3,5,7])
result = arr1 +arr2
result

"""limitation"""

arr1 = np.array([[1,3,5,7] ,[1,3,5,7]])
arr2 = np.array([1,3,5]) # if the number of col/items nor equal will not work
result = arr1 +arr2
result

# multiplication is element wise multiplication
A = np.array([[1,3,5] ,
              [2,3,4]])

B = np.array([[1,3,5] ,
             [1,3,7]])

res  = A*B
res

B_T = B.T
res = A.dot(B_T)
res

"""# triangles"""

arr = np.array([[1,2,3],
                [1,2,3],
                [1,2,3]])

lower = np.tril(arr)
lower

upper = np.triu(arr)
upper

"""#diagonal"""

d= np.diag(arr)
d

D= np.diag(d)
D

#idntity matrix
arr = np.identity(3)
arr

#idntity matrix
arr = np.eye(3)
arr

"""#matrix operations"""

#transpose
arr = np.array([[1,2],
                [1,2],
                [1,3]])
c = arr.T
c

"""A * A^(-1) = identity matrix"""

# inverse matrix (to get the inverse the matrix must be square matix)
arr = np.array([[1, 2],
                [3, 4]])
c = np.linalg.inv(arr)
c

# to make sure the identity is true
res = arr.dot(c)
res

"""Trace is summation of diagonal"""

arr = np.array([[1,2,3],
                [1,2,3],
                [1,2,3]])
trace = np.trace(arr)
trace

"""#dependat of matrix"""

#

"""#search about rank"""